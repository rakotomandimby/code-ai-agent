# Make the LLM API keys to be obtained fron the clients. 

Currently, I must set the LLM API keys as environment variables:

- `OPENAI_API_KEY` - OpenAI API authentication
- `GOOGLEAI_API_KEY` - Google AI API authentication  
- `ANTHROPIC_API_KEY` - Anthropic API authentication

I dont like that. I want the clients to provide the API keys in the requests.

I still hesitate on how to do that, because the priority is to have the same architecture as the existing.
So, my first idea is to add a new table to the existing database schema, called `api_key` with the following structure:

```sql
CREATE TABLE api_key (
    id INTEGER,
    value TEXT
)
```

What is your opinion on that? Do not provide any code yet, just your opinion.
If your opinion differs from mine, explain it.


# OPN Recommend passing API keys via request headers and never persisting them, rather than adding an api_key table

You want clients to provide provider API keys with each request instead of using environment variables. The goal is to keep the same architecture and behavior. My recommendation is to avoid persisting API keys in SQLite entirely and instead accept them transiently via request headers, forwarding them to the provider per request. This preserves your existing router and Template Method structure, requires minimal code changes, avoids storing secrets at rest, and reduces risk.

Here’s my reasoning and comparison:

- Security and compliance
  - Against adding an api_key table: Storing API keys in SQLite as plaintext (even under /tmp) is a major security risk. If the process crashes before clear(), keys can linger. Backups, logs, or accidental dumps could expose them. If you do persist them, you should at least encrypt at rest and manage a server-side master key, which complicates the setup and defeats the simplicity you’re after.
  - For passing keys via headers: No secrets at rest. Keys remain in memory for the duration of a single request and are not written to disk. This aligns with least-privilege and common multi-tenant patterns.

- Fit with current flow and architecture
  - Your current request flow has a “trigger” POST with empty body that executes the provider call after a 1-second delay. That happens inside the same HTTP request closure, so you can access req.headers during that process without needing persistence. This fits perfectly with per-request headers.
  - Adding an api_key table only to immediately clear it after the provider call adds complexity and risk without benefit.

- Concurrency and correctness
  - DB-backed storage for API keys introduces race conditions between multiple clients unless you add a session or conversation ID to isolate state, which you don’t currently have. With per-request headers, credentials are scoped to that request and not shared or mixed.
  - Your AIHttpClient currently uses axios.defaults.headers.common, which is global and could cause leakage between concurrent requests if not changed. Moving to per-request headers (not defaults) further improves thread-safety and correctness.

- Operational simplicity
  - Keeping keys out of the DB avoids schema changes, migrations, and clear() updates.
  - Clients can use the natural provider headers:
    - OpenAI: Authorization: Bearer sk-...
    - Google AI: x-goog-api-key: ...
    - Anthropic: x-api-key: ...
  - If some clients cannot set headers, you could optionally accept an api_key field in the body of the trigger call only (still not persisted), but headers are the cleanest path.

- Logging and debugging implications
  - Ensure you never log request headers or forward them to debug endpoints (Pipedream). Keeping keys transient reduces accidental exposure in logs.
  - If you keep debugURL support, make sure any debug path is disabled or scrubbed of auth headers.

- If you still want DB storage
  - Only consider it if you implement encryption-at-rest and key rotation, introduce a session/conversation identifier to segment keys safely, ensure strict clear() on all code paths, and accept the risk/complexity. For your stated priority (keeping architecture the same) and simplicity, this is not necessary.

Summary recommendation:
- Do not add an api_key table.
- Accept provider API keys via request headers on the trigger request and forward them to the provider in that call.
- Adjust AIHttpClient to support per-request headers (avoid axios.defaults) and add a simple setAuth(...) method.
- In createAgentRouter, extract the header relevant to the agent service and pass it to the AIHttpClient instance right before post().
- Keep all secrets out of SQLite and logs.

Files modified or created in this step: None (you asked for opinion only).

OpenAI gpt-5 (14k in, 2k out)


